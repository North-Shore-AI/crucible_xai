defmodule CrucibleXAI.Explanation do
  @moduledoc """
  Explanation structure for XAI methods.

  This module defines the common structure for explanations generated by
  various XAI methods (LIME, SHAP, feature attribution, etc.) and provides
  utility functions for analyzing and visualizing explanations.

  ## Fields

    * `:instance` - The instance being explained
    * `:feature_weights` - Map of feature_index => weight/importance
    * `:intercept` - Intercept/baseline value (optional)
    * `:score` - Quality score of the explanation (e.g., R² for LIME)
    * `:method` - The XAI method used (`:lime`, `:shap`, `:permutation`, etc.)
    * `:metadata` - Additional method-specific metadata

  ## Examples

      iex> explanation = %CrucibleXAI.Explanation{
      ...>   instance: [1.0, 2.0, 3.0],
      ...>   feature_weights: %{0 => 0.5, 1 => -0.3, 2 => 0.8},
      ...>   intercept: 1.0,
      ...>   score: 0.95,
      ...>   method: :lime,
      ...>   metadata: %{num_samples: 5000}
      ...> }
      iex> explanation.method
      :lime
  """

  @type t :: %__MODULE__{
          instance: any(),
          feature_weights: %{integer() => float()},
          intercept: float() | nil,
          score: float() | nil,
          method: atom(),
          metadata: map()
        }

  defstruct [
    :instance,
    :feature_weights,
    :intercept,
    :score,
    :method,
    :metadata
  ]

  @doc """
  Get top k features by absolute weight.

  Returns a list of {feature_index, weight} tuples sorted by absolute weight
  in descending order.

  ## Parameters
    * `explanation` - The explanation struct
    * `k` - Number of top features to return

  ## Returns
    List of {feature_index, weight} tuples

  ## Examples
      iex> explanation = %CrucibleXAI.Explanation{
      ...>   instance: [1, 2, 3],
      ...>   feature_weights: %{0 => 0.5, 1 => -0.8, 2 => 0.3},
      ...>   method: :lime
      ...> }
      iex> CrucibleXAI.Explanation.top_features(explanation, 2)
      [{1, -0.8}, {0, 0.5}]
  """
  @spec top_features(t(), pos_integer()) :: list({integer(), float()})
  def top_features(%__MODULE__{feature_weights: weights}, k) do
    weights
    |> Enum.sort_by(fn {_idx, weight} -> abs(weight) end, :desc)
    |> Enum.take(k)
  end

  @doc """
  Get positive features (features that increase prediction).

  Returns features with positive weights, sorted by weight in descending order.

  ## Parameters
    * `explanation` - The explanation struct

  ## Returns
    List of {feature_index, weight} tuples for positive features

  ## Examples
      iex> explanation = %CrucibleXAI.Explanation{
      ...>   instance: [1, 2, 3],
      ...>   feature_weights: %{0 => 0.5, 1 => -0.3, 2 => 0.8},
      ...>   method: :lime
      ...> }
      iex> CrucibleXAI.Explanation.positive_features(explanation)
      [{2, 0.8}, {0, 0.5}]
  """
  @spec positive_features(t()) :: list({integer(), float()})
  def positive_features(%__MODULE__{feature_weights: weights}) do
    weights
    |> Enum.filter(fn {_idx, weight} -> weight > 0 end)
    |> Enum.sort_by(fn {_idx, weight} -> weight end, :desc)
  end

  @doc """
  Get negative features (features that decrease prediction).

  Returns features with negative weights, sorted by absolute weight in
  descending order.

  ## Parameters
    * `explanation` - The explanation struct

  ## Returns
    List of {feature_index, weight} tuples for negative features

  ## Examples
      iex> explanation = %CrucibleXAI.Explanation{
      ...>   instance: [1, 2, 3],
      ...>   feature_weights: %{0 => 0.5, 1 => -0.8, 2 => -0.3},
      ...>   method: :lime
      ...> }
      iex> CrucibleXAI.Explanation.negative_features(explanation)
      [{1, -0.8}, {2, -0.3}]
  """
  @spec negative_features(t()) :: list({integer(), float()})
  def negative_features(%__MODULE__{feature_weights: weights}) do
    weights
    |> Enum.filter(fn {_idx, weight} -> weight < 0 end)
    |> Enum.sort_by(fn {_idx, weight} -> abs(weight) end, :desc)
  end

  @doc """
  Get feature importance as absolute values.

  Returns all features sorted by absolute importance (absolute value of weight).

  ## Parameters
    * `explanation` - The explanation struct

  ## Returns
    List of {feature_index, absolute_importance} tuples

  ## Examples
      iex> explanation = %CrucibleXAI.Explanation{
      ...>   instance: [1, 2, 3],
      ...>   feature_weights: %{0 => 0.5, 1 => -0.8, 2 => 0.3},
      ...>   method: :lime
      ...> }
      iex> CrucibleXAI.Explanation.feature_importance(explanation)
      [{1, 0.8}, {0, 0.5}, {2, 0.3}]
  """
  @spec feature_importance(t()) :: list({integer(), float()})
  def feature_importance(%__MODULE__{feature_weights: weights}) do
    weights
    |> Enum.map(fn {idx, weight} -> {idx, abs(weight)} end)
    |> Enum.sort_by(fn {_idx, importance} -> importance end, :desc)
  end

  @doc """
  Visualize explanation as text.

  Generates a human-readable text representation of the explanation.

  ## Parameters
    * `explanation` - The explanation struct
    * `opts` - Options:
      * `:num_features` - Number of features to display (default: 10)
      * `:feature_names` - Map of feature_index => name

  ## Returns
    String containing formatted explanation

  ## Examples
      iex> explanation = %CrucibleXAI.Explanation{
      ...>   instance: [1.0, 2.0],
      ...>   feature_weights: %{0 => 0.5, 1 => -0.3},
      ...>   intercept: 1.0,
      ...>   score: 0.95,
      ...>   method: :lime,
      ...>   metadata: %{}
      ...> }
      iex> text = CrucibleXAI.Explanation.to_text(explanation)
      iex> String.contains?(text, "LIME")
      true
  """
  @spec to_text(t(), keyword()) :: String.t()
  def to_text(%__MODULE__{} = explanation, opts \\ []) do
    num_features = Keyword.get(opts, :num_features, 10)
    feature_names = Keyword.get(opts, :feature_names, %{})

    method_name = explanation.method |> to_string() |> String.upcase()

    """
    #{method_name} Explanation
    #{String.duplicate("=", 50)}

    Method: #{explanation.method}
    #{format_optional_field("Score", explanation.score)}
    #{format_optional_field("Intercept", explanation.intercept)}

    Top Features (by absolute importance):
    #{format_feature_weights(explanation.feature_weights, num_features, feature_names)}

    Positive Contributors:
    #{format_features(positive_features(explanation), feature_names)}

    Negative Contributors:
    #{format_features(negative_features(explanation), feature_names)}
    """
  end

  @doc """
  Convert explanation to JSON-serializable map.

  ## Parameters
    * `explanation` - The explanation struct

  ## Returns
    Map with string keys suitable for JSON encoding

  ## Examples
      iex> explanation = %CrucibleXAI.Explanation{
      ...>   instance: [1.0, 2.0],
      ...>   feature_weights: %{0 => 0.5, 1 => 0.3},
      ...>   method: :lime
      ...> }
      iex> map = CrucibleXAI.Explanation.to_map(explanation)
      iex> map.method
      "lime"
  """
  @spec to_map(t()) :: map()
  def to_map(%__MODULE__{} = explanation) do
    %{
      instance: explanation.instance,
      feature_weights: convert_keys_to_strings(explanation.feature_weights),
      intercept: explanation.intercept,
      score: explanation.score,
      method: to_string(explanation.method),
      metadata: explanation.metadata || %{}
    }
  end

  # Private helper functions

  defp format_optional_field(_name, nil), do: ""

  defp format_optional_field(name, value) when is_float(value) do
    "#{name}: #{Float.round(value, 4)}"
  end

  defp format_optional_field(name, value) do
    "#{name}: #{value}"
  end

  defp format_feature_weights(weights, num_features, feature_names) do
    weights
    |> Enum.sort_by(fn {_, w} -> abs(w) end, :desc)
    |> Enum.take(num_features)
    |> Enum.map_join("\n", fn {idx, weight} ->
      name = Map.get(feature_names, idx, "Feature #{idx}")
      sign = if weight > 0, do: "+", else: ""
      bar = progress_bar(abs(weight), 0.0, max_weight(weights))
      "  #{name}: #{sign}#{Float.round(weight, 4)} #{bar}"
    end)
  end

  defp format_features(features, feature_names) do
    if Enum.empty?(features) do
      "  (none)"
    else
      Enum.map_join(features, "\n", fn {idx, weight} ->
        name = Map.get(feature_names, idx, "Feature #{idx}")
        "  #{name}: #{Float.round(weight, 4)}"
      end)
    end
  end

  defp max_weight(weights) do
    weights
    |> Enum.map(fn {_, w} -> abs(w) end)
    |> Enum.max(fn -> 1.0 end)
  end

  defp progress_bar(_value, min, max) when max == min, do: ""

  defp progress_bar(value, min, max) do
    width = 20
    normalized = (value - min) / (max - min)
    filled = round(normalized * width)
    String.duplicate("█", filled) <> String.duplicate("░", width - filled)
  end

  defp convert_keys_to_strings(map) when is_map(map) do
    Map.new(map, fn {k, v} -> {to_string(k), v} end)
  end

  defp convert_keys_to_strings(other), do: other
end
